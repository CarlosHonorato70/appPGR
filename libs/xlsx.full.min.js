/*! XLSX.js v0.18.5 - Local fallback version for appPGR */
(function(global) {
    'use strict';

    var XLSX = {
        utils: {
            book_new: function() {
                return {
                    SheetNames: [],
                    Sheets: {}
                };
            },
            
            aoa_to_sheet: function(data) {
                var ws = {};
                var range = {s: {c: 0, r: 0}, e: {c: 0, r: 0}};
                
                for (var R = 0; R < data.length; ++R) {
                    for (var C = 0; C < data[R].length; ++C) {
                        if (range.s.r > R) range.s.r = R;
                        if (range.s.c > C) range.s.c = C;
                        if (range.e.r < R) range.e.r = R;
                        if (range.e.c < C) range.e.c = C;
                        
                        var cell_ref = this.encode_cell({c: C, r: R});
                        var cell = {v: data[R][C]};
                        
                        if (cell.v == null) continue;
                        
                        if (typeof cell.v === 'number') cell.t = 'n';
                        else if (typeof cell.v === 'boolean') cell.t = 'b';
                        else cell.t = 's';
                        
                        ws[cell_ref] = cell;
                    }
                }
                if (range.s.c < 10000000) ws['!ref'] = this.encode_range(range);
                return ws;
            },
            
            book_append_sheet: function(wb, ws, name) {
                if (!wb.SheetNames) wb.SheetNames = [];
                if (!wb.Sheets) wb.Sheets = {};
                wb.SheetNames.push(name);
                wb.Sheets[name] = ws;
            },
            
            encode_cell: function(cell) {
                return String.fromCharCode(65 + cell.c) + (cell.r + 1);
            },
            
            encode_range: function(range) {
                return this.encode_cell(range.s) + ':' + this.encode_cell(range.e);
            }
        },
        
        writeFile: function(wb, filename) {
            // Convert to CSV format for simplicity
            var csv = '';
            var sheetName = wb.SheetNames[0];
            var ws = wb.Sheets[sheetName];
            
            // Extract data from worksheet
            var data = [];
            var ref = ws['!ref'];
            if (!ref) return;
            
            var range = this.utils.decode_range(ref);
            for (var R = range.s.r; R <= range.e.r; ++R) {
                var row = [];
                for (var C = range.s.c; C <= range.e.c; ++C) {
                    var cell_ref = this.utils.encode_cell({c: C, r: R});
                    var cell = ws[cell_ref];
                    if (cell && cell.v != null) {
                        row.push(cell.v);
                    } else {
                        row.push('');
                    }
                }
                data.push(row);
            }
            
            // Convert to CSV
            csv = data.map(function(row) {
                return row.map(function(cell) {
                    return '"' + String(cell).replace(/"/g, '""') + '"';
                }).join(',');
            }).join('\n');
            
            // Download as file
            var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            var url = window.URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename.replace('.xlsx', '.csv');
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    };
    
    // Add decode_range function
    XLSX.utils.decode_range = function(range) {
        var parts = range.split(':');
        return {
            s: this.decode_cell(parts[0]),
            e: this.decode_cell(parts[1])
        };
    };
    
    XLSX.utils.decode_cell = function(cell) {
        var match = cell.match(/([A-Z]+)(\d+)/);
        if (!match) return {c: 0, r: 0};
        
        var col = 0;
        var letters = match[1];
        for (var i = 0; i < letters.length; i++) {
            col = col * 26 + (letters.charCodeAt(i) - 64);
        }
        col -= 1;
        
        var row = parseInt(match[2]) - 1;
        return {c: col, r: row};
    };

    // Export to global scope
    global.XLSX = XLSX;

})(typeof window !== 'undefined' ? window : this);