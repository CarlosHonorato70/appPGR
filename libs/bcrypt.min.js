/**
 * Simple bcrypt-like implementation for frontend password hashing
 * This is a simplified version for demonstration - in production, use proper bcrypt library
 */
(function(global) {
    'use strict';

    // Simple salt generation
    function generateSalt(rounds = 10) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./';
        let salt = '$2a$' + (rounds < 10 ? '0' + rounds : rounds) + '$';
        for (let i = 0; i < 22; i++) {
            salt += chars[Math.floor(Math.random() * chars.length)];
        }
        return salt;
    }

    // Simple hash function using Web Crypto API
    async function hashPassword(password, salt) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password + salt);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return salt + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Simple hash function (synchronous version for compatibility)
    function hashPasswordSync(password, salt) {
        // Simple hash using built-in string methods (for demonstration)
        let hash = 0;
        const combined = password + salt;
        for (let i = 0; i < combined.length; i++) {
            const char = combined.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return salt + Math.abs(hash).toString(16);
    }

    const bcrypt = {
        // Generate salt
        genSaltSync: function(rounds = 10) {
            return generateSalt(rounds);
        },

        // Hash password synchronously
        hashSync: function(password, salt) {
            if (typeof salt === 'number') {
                salt = generateSalt(salt);
            }
            return hashPasswordSync(password, salt);
        },

        // Compare password with hash
        compareSync: function(password, hash) {
            const salt = hash.substring(0, 29); // Extract salt from hash
            const newHash = hashPasswordSync(password, salt);
            return newHash === hash;
        },

        // Async versions
        genSalt: function(rounds = 10) {
            return Promise.resolve(generateSalt(rounds));
        },

        hash: async function(password, salt) {
            if (typeof salt === 'number') {
                salt = generateSalt(salt);
            }
            if (crypto.subtle) {
                return await hashPassword(password, salt);
            } else {
                return hashPasswordSync(password, salt);
            }
        },

        compare: async function(password, hash) {
            const salt = hash.substring(0, 29);
            let newHash;
            if (crypto.subtle) {
                newHash = await hashPassword(password, salt);
            } else {
                newHash = hashPasswordSync(password, salt);
            }
            return newHash === hash;
        }
    };

    // Export for different environments
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = bcrypt;
    } else if (typeof define === 'function' && define.amd) {
        define(function() { return bcrypt; });
    } else {
        global.bcrypt = bcrypt;
    }

})(typeof window !== 'undefined' ? window : this);